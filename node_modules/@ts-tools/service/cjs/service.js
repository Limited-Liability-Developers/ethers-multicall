"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const create_host_1 = require("./create-host");
/**
 * On-demand TypeScript tranpilation service
 * Options can be provided during construction
 *
 * @example
 * new TypeScriptService()
 * new TypeScriptService({ tsconfigFileName: 'tsconfig.test.json' })
 */
class TypeScriptService {
    constructor() {
        // a map holding `tsconfig path` to a `language service instance`
        this.runningServices = new Map();
        // might create multiple language services, so share documents between them
        this.documentRegistries = new Map();
        // cache of `directory path` to `tsconfig lookup result`, to save disk operations
        this.directoryToTsConfig = new Map();
    }
    /**
     * Transpile a TypeScript file on the native file system
     *
     * @param filePath absolute path of the source file to transpile
     */
    transpileFile(filePath, transpileOptions) {
        // search and use an existing service that targets `filePath`
        for (const existingInstance of this.runningServices.values()) {
            if (existingInstance.rootFileNames.has(filePath)) {
                return this.transpileUsingLanguageService(filePath, existingInstance.languageService, existingInstance.baseHost);
            }
        }
        // create base host
        const { getCustomFs, tsconfigFileName, isolated, cwd = typescript_1.default.sys.getCurrentDirectory() } = transpileOptions;
        const customFs = getCustomFs && getCustomFs();
        const baseHost = customFs ? create_host_1.createCustomFsBaseHost(cwd, customFs) : create_host_1.createBaseHost(cwd);
        const { dirname, fileExists, readFile } = baseHost;
        if (isolated) {
            // user explicitly specified no tsconfig lookup
            return this.transpileIsolated(filePath, baseHost, transpileOptions);
        }
        // search for tsconfig
        const fileDirectoryPath = dirname(filePath);
        const configFilePath = this.getTsConfigPath(fileDirectoryPath, fileExists, tsconfigFileName);
        if (!configFilePath) {
            // couldn't find tsconfig, so tranpile w/o type checking
            return this.transpileIsolated(filePath, baseHost, transpileOptions);
        }
        // read and parse config
        const jsonSourceFile = typescript_1.default.readJsonConfigFile(configFilePath, readFile);
        const configDirectoryPath = dirname(configFilePath);
        const { errors, fileNames, options: tsconfigOptions } = typescript_1.default.parseJsonSourceFileConfigFileContent(jsonSourceFile, baseHost, configDirectoryPath);
        if (errors.length) {
            return {
                diagnostics: errors,
                filePath,
                outputText: '',
                baseHost
            };
        }
        // create a new language service based on tsconfig
        const serviceInstance = this.createLanguageService(fileNames, baseHost, transpileOptions, tsconfigOptions, customFs);
        // register new language service
        this.runningServices.set(configFilePath, serviceInstance);
        const { languageService, rootFileNames } = serviceInstance;
        if (rootFileNames.has(filePath)) {
            // service includes our file, so use it to transpile
            return this.transpileUsingLanguageService(filePath, languageService, baseHost);
        }
        // no matching service, so tranpile w/o type checking
        return this.transpileIsolated(filePath, baseHost, transpileOptions);
    }
    /**
     * Clears all running language services, document registries,
     * and tsconfig resolution cache.
     */
    clear() {
        this.runningServices.clear();
        this.documentRegistries.clear();
        this.directoryToTsConfig.clear();
    }
    transpileUsingLanguageService(filePath, languageService, baseHost) {
        const { outputFiles, emitSkipped } = languageService.getEmitOutput(filePath);
        if (emitSkipped) {
            return {
                filePath,
                diagnostics: [
                    this.createErrorDiagnostic('Emit was skipped')
                ],
                outputText: '',
                baseHost
            };
        }
        const [jsOutputFile] = outputFiles.filter(outputFile => outputFile.name.endsWith('.js'));
        if (!jsOutputFile) {
            return {
                filePath,
                diagnostics: [
                    this.createErrorDiagnostic('No js output file was found')
                ],
                outputText: '',
                baseHost
            };
        }
        const [sourceMapOutputFile] = outputFiles.filter(outputFile => outputFile.name.endsWith('.js.map'));
        const sourceMapText = sourceMapOutputFile && sourceMapOutputFile.text;
        const program = languageService.getProgram();
        const sourceFile = program && program.getSourceFile(filePath);
        const syntacticDiagnostics = languageService.getSyntacticDiagnostics(filePath);
        let diagnostics;
        if (syntacticDiagnostics.length) {
            diagnostics = syntacticDiagnostics;
        }
        else {
            const semanticDiagnostics = languageService.getSemanticDiagnostics(filePath);
            if (semanticDiagnostics.length) {
                diagnostics = semanticDiagnostics;
            }
        }
        return {
            diagnostics,
            filePath,
            outputText: jsOutputFile.text,
            sourceMapText,
            baseHost,
            resolvedModules: sourceFile && sourceFile.resolvedModules
        };
    }
    transpileIsolated(filePath, baseHost, options) {
        const tsCode = baseHost.readFile(filePath);
        if (tsCode === undefined) {
            return {
                filePath,
                diagnostics: [
                    this.createErrorDiagnostic(`Unable to read ${filePath}`)
                ],
                outputText: '',
                baseHost
            };
        }
        const { getCustomTransformers, getCompilerOptions } = options;
        const transformers = getCustomTransformers && getCustomTransformers(baseHost);
        const compilerOptions = getCompilerOptions(baseHost);
        const { outputText, diagnostics, sourceMapText } = typescript_1.default.transpileModule(tsCode, { compilerOptions, transformers, fileName: filePath });
        return {
            filePath,
            outputText,
            sourceMapText,
            diagnostics,
            baseHost
        };
    }
    /**
     * Find the closest `tsconfig.json` file to the provided baseDirectory
     *
     * @param baseDirectory the directory to start looking from
     */
    getTsConfigPath(baseDirectory, fileExists, tsconfigFileName) {
        if (this.directoryToTsConfig.has(baseDirectory)) {
            return this.directoryToTsConfig.get(baseDirectory);
        }
        const tsConfigPath = typescript_1.default.findConfigFile(baseDirectory, fileExists, tsconfigFileName);
        this.directoryToTsConfig.set(baseDirectory, tsConfigPath);
        return tsConfigPath;
    }
    createLanguageService(fileNames, baseHost, transpileOptions, tsconfigOptions, customFs) {
        const { getCustomTransformers, getCompilerOptions } = transpileOptions;
        const customTransformers = getCustomTransformers && getCustomTransformers(baseHost, tsconfigOptions);
        const compilerOptions = getCompilerOptions(baseHost, tsconfigOptions);
        const languageServiceHost = customFs ?
            create_host_1.createCustomFsLanguageServiceHost(baseHost, fileNames, compilerOptions, customFs, customTransformers) :
            create_host_1.createLanguageServiceHost(baseHost, fileNames, compilerOptions, customTransformers);
        const { getCurrentDirectory, useCaseSensitiveFileNames } = baseHost;
        const documentRegistry = this.getDocumentRegistry(getCurrentDirectory(), useCaseSensitiveFileNames);
        const serviceInstance = {
            baseHost,
            rootFileNames: new Set(fileNames.map(baseHost.normalize)),
            languageService: typescript_1.default.createLanguageService(languageServiceHost, documentRegistry)
        };
        return serviceInstance;
    }
    getDocumentRegistry(cwd, caseSensitive) {
        const registryKey = cwd + caseSensitive;
        const existingRegistry = this.documentRegistries.get(registryKey);
        if (existingRegistry) {
            return existingRegistry;
        }
        const documentRegistry = typescript_1.default.createDocumentRegistry(caseSensitive, cwd);
        this.documentRegistries.set(registryKey, documentRegistry);
        return documentRegistry;
    }
    createErrorDiagnostic(messageText) {
        return {
            messageText,
            category: typescript_1.default.DiagnosticCategory.Error,
            code: typescript_1.default.DiagnosticCategory.Error,
            file: undefined,
            start: 0,
            length: undefined
        };
    }
}
exports.TypeScriptService = TypeScriptService;
//# sourceMappingURL=service.js.map