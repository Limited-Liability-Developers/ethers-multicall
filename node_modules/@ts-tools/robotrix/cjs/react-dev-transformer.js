"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const SELF = '__self';
const SOURCE = '__source';
const JSX_FILENAME = '__jsxFileName';
/**
 * Transformer that adds meta-data which is used by React for development error messages.
 *
 * It adds the following attributes to all JSX elements:
 *  1. __self={this}
 *  2. __source={{ fileName: __jsxFileName, lineNumber: [jsx line number] }}
 *
 * if __source was added, the following declaration is prepended to source file:
 *   const __jsxFileName = [absolute file path]
 */
function reactDevTransformer(context) {
    return sourceFile => {
        const { fileName } = sourceFile; // absolute file path
        // we want to add the __jsxFileName const only if it is used in any added attribute
        let shouldAddFileNameConst = false;
        // file-wide unique identifier that would point to the fileName string literal
        const jsxFileNameIdentifier = typescript_1.default.createFileLevelUniqueName(JSX_FILENAME);
        // fist run the visitor, so it will mark whether we need to add fileName const declaration
        sourceFile = typescript_1.default.visitEachChild(sourceFile, addJSXMetadata, context);
        if (shouldAddFileNameConst) {
            sourceFile = addFileNameConst(sourceFile, jsxFileNameIdentifier, fileName);
        }
        return sourceFile;
        function addJSXMetadata(node) {
            // we only transform jsx attributes nodes that have parent jsx elements
            if (!typescript_1.default.isJsxAttributes(node) || !node.parent) {
                return typescript_1.default.visitEachChild(node, addJSXMetadata, context);
            }
            const { userDefinedSelf, userDefinedSource } = findUserDefinedAttributes(node);
            const newAttributes = [];
            if (!userDefinedSelf) {
                newAttributes.push(createSelfAttribute());
            }
            if (!userDefinedSource) {
                shouldAddFileNameConst = true;
                const { line } = typescript_1.default.getLineAndCharacterOfPosition(sourceFile, node.parent.pos);
                newAttributes.push(createSourceAttribute(createLocationObject(jsxFileNameIdentifier, line)));
            }
            if (newAttributes.length) {
                // we actually created new attributes, so append them
                node = typescript_1.default.updateJsxAttributes(node, node.properties.concat(newAttributes));
            }
            // if any of the attributes contain JSX elements, we want to transform them as well
            return typescript_1.default.visitEachChild(node, addJSXMetadata, context);
        }
    };
}
exports.reactDevTransformer = reactDevTransformer;
// iterate over existing properties to check whether user already defined one of the props
function findUserDefinedAttributes(node) {
    let userDefinedSelf = false;
    let userDefinedSource = false;
    for (const prop of node.properties) {
        const { name: propName } = prop;
        if (propName && (typescript_1.default.isIdentifier(propName) || typescript_1.default.isStringLiteral(propName))) {
            if (propName.text === SELF) {
                userDefinedSelf = true;
            }
            else if (propName.text === SOURCE) {
                userDefinedSource = true;
            }
        }
    }
    return { userDefinedSelf, userDefinedSource };
}
// __self={this}
function createSelfAttribute() {
    return typescript_1.default.createJsxAttribute(typescript_1.default.createIdentifier(SELF), typescript_1.default.createJsxExpression(undefined, typescript_1.default.createThis()));
}
// __source={ [location-object] }
function createSourceAttribute(locationObj) {
    return typescript_1.default.createJsxAttribute(typescript_1.default.createIdentifier(SOURCE), typescript_1.default.createJsxExpression(undefined, locationObj));
}
// { fileName: [path-to-file], lineNumber: [element-line-number] }
function createLocationObject(jsxFileNameIdentifier, line) {
    return typescript_1.default.createObjectLiteral([
        typescript_1.default.createPropertyAssignment('fileName', jsxFileNameIdentifier // use the file-wide identifier for fileName value
        ),
        typescript_1.default.createPropertyAssignment('lineNumber', typescript_1.default.createNumericLiteral(String(line + 1)))
    ]);
}
// const __jsxFileName = "/path/to/file.ts"
function addFileNameConst(sourceFile, jsxFileNameIdentifier, fileName) {
    const variableDecls = [
        typescript_1.default.createVariableDeclaration(jsxFileNameIdentifier, undefined /* type */, typescript_1.default.createStringLiteral(fileName))
    ];
    return insertStatementAfterImports(sourceFile, typescript_1.default.createVariableStatement(undefined /* modifiers */, typescript_1.default.createVariableDeclarationList(variableDecls, typescript_1.default.NodeFlags.Const)));
}
// insert a new statement above the first non-import statement
function insertStatementAfterImports(sourceFile, statement) {
    const { statements } = sourceFile;
    const nonImportIdx = statements.findIndex(s => !typescript_1.default.isImportDeclaration(s));
    const newStatements = nonImportIdx === -1 ?
        [statement, ...statements] :
        [...statements.slice(0, nonImportIdx), statement, ...statements.slice(nonImportIdx)];
    return typescript_1.default.updateSourceFileNode(sourceFile, newStatements);
}
//# sourceMappingURL=react-dev-transformer.js.map