"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
/**
 * Transforms CommonJS calls/exports to ESM syntax.
 * If a source file is identified as using `require`, `module`, or `exports`,
 * it is wrapped with the following:
 * ```
 * [generated imports]
 * let exports = {}, module = { exports }
 *
 * [original code]
 *
 * export default module.exports
 * ```
 *
 * Each `require(...)` call is converted to a generated import statement
 * with a unique identifier.
 */
function createCjsToEsmTransformer(options = {}) {
    return context => sourceFile => transformSourceFile(sourceFile, context, options);
}
exports.createCjsToEsmTransformer = createCjsToEsmTransformer;
function transformSourceFile(sourceFile, context, { shouldTransform = () => true }) {
    let fileUsesCommonJs = false;
    const newImports = [];
    sourceFile = typescript_1.default.visitEachChild(sourceFile, visitCommonJS, context);
    if (fileUsesCommonJs) {
        const newStatements = [
            ...newImports,
            createCjsModuleDefinition(),
            ...sourceFile.statements,
            createCjsExportDefault()
        ];
        sourceFile = typescript_1.default.updateSourceFileNode(sourceFile, newStatements);
    }
    return sourceFile;
    function visitCommonJS(node) {
        if (typescript_1.default.isFunctionLike(node) &&
            node.parameters.some(({ name }) => typescript_1.default.isIdentifier(name) && name.text === 'require')) {
            // do no iterate into bodys of functions defining a `require` parameter
            // mocha's bundle uses this pattern. we don't want to transform `require`
            // calls inside such functions
            return node;
        }
        else if (isCjsExportsAccess(node)) {
            fileUsesCommonJs = true;
        }
        else if (isCJsRequireCall(node) && shouldTransform(node.arguments[0].text)) {
            fileUsesCommonJs = true;
            const importIdentifier = createImportIdentifier(node);
            newImports.push(typescript_1.default.createImportDeclaration(undefined /* decorators */, undefined /* modifiers */, typescript_1.default.createImportClause(importIdentifier, undefined /* namedBindings */), node.arguments[0]));
            // replace require call with identifier
            return importIdentifier;
        }
        return typescript_1.default.visitEachChild(node, visitCommonJS, context);
    }
}
// export default module.exports
function createCjsExportDefault() {
    return typescript_1.default.createExportDefault(typescript_1.default.createPropertyAccess(typescript_1.default.createIdentifier('module'), 'exports'));
}
// unique identifier generation
function createImportIdentifier(node) {
    const { parent } = node;
    if (parent && typescript_1.default.isVariableDeclaration(parent) && typescript_1.default.isIdentifier(parent.name)) {
        // var libName = require(...)
        // so use libName
        return typescript_1.default.createUniqueName(parent.name.text);
    }
    else {
        // use _imported_1, _imported_2, etc
        return typescript_1.default.createUniqueName('_imported');
    }
}
// let exports = {}, module = { exports }
function createCjsModuleDefinition() {
    return typescript_1.default.createVariableStatement(undefined /* modifiers */, typescript_1.default.createVariableDeclarationList([
        typescript_1.default.createVariableDeclaration('exports', undefined /* type */, typescript_1.default.createObjectLiteral()),
        typescript_1.default.createVariableDeclaration('module', undefined /* type */, typescript_1.default.createObjectLiteral([typescript_1.default.createShorthandPropertyAssignment('exports')]))
    ], typescript_1.default.NodeFlags.Let));
}
// module['exports'], module.exports or exports.<something>
function isCjsExportsAccess(node) {
    if (typescript_1.default.isElementAccessExpression(node) &&
        typescript_1.default.isIdentifier(node.expression) &&
        node.expression.text === 'module' &&
        typescript_1.default.isStringLiteral(node.argumentExpression)) {
        // module['exports']
        return node.argumentExpression.text === 'exports';
    }
    else if (typescript_1.default.isPropertyAccessExpression(node) && typescript_1.default.isIdentifier(node.expression)) {
        return (node.expression.text === 'module' && node.name.text === 'exports') || // module.exports
            (node.expression.text === 'exports'); // exports.<something>
    }
    return false;
}
// require(...) calls with a single string argument
function isCJsRequireCall(node) {
    return (typescript_1.default.isCallExpression(node) &&
        typescript_1.default.isIdentifier(node.expression) &&
        node.expression.text === 'require' &&
        node.arguments.length === 1 &&
        typescript_1.default.isStringLiteral(node.arguments[0]));
}
//# sourceMappingURL=cjs-to-esm-transformer.js.map